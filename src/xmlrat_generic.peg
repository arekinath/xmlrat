document <- prolog element misc* `lists:flatten(Node)`;

prolog <- xmldecl? misc* (doctypedecl misc*)? `lists:flatten(Node)`;
xmldecl <- "<?xml" xmlver encoding? sddecl? s? "?>" `
  Opts = maps:from_list([X || X = {K, _V} <- Node, is_atom(K)]),
  #{version := Ver} = Opts,
  {xml, Ver, maps:remove(version, Opts)}
`;
xmlver <- s "version" eq ['"] v:vernum ['"] `
  V = proplists:get_value(v, Node),
  {version, V}
`;
vernum <- "1." [0-9]+ `iolist_to_binary(Node)`;
sddecl <- s "standalone" eq ['"] v:("yes" / "no") ['"] `
  V = proplists:get_value(v, Node),
  {standalone, binary_to_atom(iolist_to_binary(V))}
`;
encoding <- s "encoding" eq ['"] v:encname ["'] `
  V = proplists:get_value(v, Node),
  {encoding, V}
`;
encname <- [A-Za-z] [A-Za-z0-9._-]* `iolist_to_binary(Node)`;

doctypedecl <- "<!DOCTYPE" s n:name extid:(s externalid)? s? subset:("[" intsubset "]" s?)? ">" `
  Opts = maps:from_list([X || X = {K, _V} <- Node, is_atom(K)]),
  #{n := Name} = Opts,
  Info0 = #{},
  Info1 = case Opts of
    #{extid := [_, Id]} -> Info0#{external_id => Id};
    _ -> Info0
  end,
  Info2 = case Opts of
    #{subset := [_, IntSubset, _, _S]} -> Info1#{subset => IntSubset};
    _ -> Info1
  end,
  {xml_doctype, Name, Info2}
`;
intsubset <- (markupdecl / declsep)*;
declsep <- peref / s ~;
markupdecl <- elementdecl / attlistdecl / entitydecl / notationdecl / pi / comment;

attlistdecl <- "a" ~;
entitydecl <- "a" ~;
notationdecl <- "a" ~;

elementdecl <- "<!ELEMENT" s n:name s c:contentspec s? ">" `
  Name = proplists:get_value(n, Node),
  Content = proplists:get_value(c, Node),
  {xmld_element, Name, Content}
`;
contentspec <- emptycs / anycs / mixed / children;
emptycs <- "EMPTY" `empty`;
anycs <- "ANY" `any`;
mixed <- mixedwn / mixeds `{mixed, Node}`;
mixedwn <- "(" s? "#PCDATA" ns:(s? "|" s? n:name)* s? ")*" `
  Ns = proplists:get_value(ns, Node),
  [proplists:get_value(n, N) || N <- Ns]
`;
mixeds <- "(" s? "#PCDATA" s? ")" `[]`;
children <- inner:(choice / seq) post:[?*+]? `
  Inner = proplists:get_value(inner, Node),
  Post = iolist_to_binary(proplists:get_value(post, Node)),
  Verb = case Post of
    <<$?>> -> zero_or_one;
    <<$*>> -> zero_or_more;
    <<$+>> -> one_or_more;
    <<>> -> one
  end,
  {Verb, Inner}
`;
cp <- inner:(name / choice / seq) post:[?*+]? `
  Inner = proplists:get_value(inner, Node),
  Post = iolist_to_binary(proplists:get_value(post, Node)),
  Verb = case Post of
    <<$?>> -> zero_or_one;
    <<$*>> -> zero_or_more;
    <<$+>> -> one_or_more;
    <<>> -> one
  end,
  {Verb, Inner}
`;
choice <- "(" s? head:cp tail:(s? "|" s? cp)+ s? ")" `
  Head = proplists:get_value(head, Node),
  Tails = proplists:get_value(tail, Node),
  Tail = [X || [_, _, _, X] <- Tails],
  {choice, [Head | Tail]}
`;
seq <- "(" s? head:cp tail:(s? "," s? cp)* s? ")" `
  Head = proplists:get_value(head, Node),
  Tails = proplists:get_value(tail, Node),
  Tail = [X || [_, _, _, X] <- Tails],
  {seq, [Head | Tail]}
`;


externalid <- systemextid / pubextid;
systemextid <- "SYSTEM" s systemlit `[_,_,A] = Node, {system, A}`;
pubextid <- "PUBLIC" s pubidlit s systemlit `[_, _, Pub, Sys] = Node, {public, Pub, Sys}`;

element <- emptyelemtag / elemtag;
elemtag <- stag content etag `
  [STag, Content, ETag] = Node,
  {xml_element, Name, Attrs, _} = STag,
  case ETag of
    {end_element, Name} -> ok;
    {end_element, OtherName} -> error({tag_close_mismatch, [{expected, Name}, {closed, OtherName}]})
  end,
  {xml_element, Name, Attrs, Content}
`;

emptyelemtag <- "<" name:name attrs:(s attribute)* s? "/>" `
  Name = proplists:get_value(name, Node),
  Attrs0 = proplists:get_value(attrs, Node),
  Attrs1 = [X || [_S, X] <- Attrs0],
  {xml_element, Name, Attrs1, []}
`;

stag <- "<" name:name attrs:(s attribute)* s? ">" `
  Name = proplists:get_value(name, Node),
  Attrs0 = proplists:get_value(attrs, Node),
  Attrs1 = [X || [_S, X] <- Attrs0],
  {xml_element, Name, Attrs1, []}
`;
attribute <- name:name eq val:attvalue `
  Name = proplists:get_value(name, Node),
  Value = proplists:get_value(val, Node),
  {xml_attribute, Name, Value}
`;
attvalue <- attvaluedq / attvaluesq `iolist_to_binary(Node)`;
attvaluedq <- ["] ([^<&"]+ / reference)* ["] `[_,V,_] = Node, V`;
attvaluesq <- ['] ([^<&']+ / reference)* ['] `[_,V,_] = Node, V`;

content <- chardata? ((element / reference / cdata / pi / comment) chardata?)* `
  {xml_content, lists:flatten(Node)}
`;

etag <- "</" n:name s? ">" `{end_element, proplists:get_value(n, Node)}`;

reference <- entityref / peref;
entityref <- "&" name ";" `[_,Name,_] = Node, {entity, Name}`;
peref <- "%" name ";" `[_,Name,_] = Node, {parameter, Name}`;

misc <- comment / pi / s;
comment <- "<!--" (!"-->" .)* "-->" `
  [_Front, Body, _Back] = Node,
  {xml_comment, iolist_to_binary(Body)}
`;
cdata <- "<![CDATA[" (!"]]>" .)* "]]>" `
  [_Front, Body, _Back] = Node,
  iolist_to_binary(Body)
`;
pi <- "<?" pitarget (s (!"?>" .)*)? "?>" `
  [_, Target, OptPart] = Node,
  Options = case OptPart of
    [_S, Rest] -> iolist_to_binary(Rest);
    _ -> undefined
  end,
  {xml_pi, Target, Options}
`;

systemlit <- systemlitdq / systemlitsq;
systemlitdq <- ["] (!["] .)* ["] `[_,A,_] = Node, iolist_to_binary(A)`;
systemlitsq <- ['] (!['] .)* ['] `[_,A,_] = Node, iolist_to_binary(A)`;
pubidlit <- pubidlitdq / pubidlitsq;
pubidlitdq <- ["] [a-zA-Z0-9'()+,./:=?;!*#@$_%\x20\x0d\x0a-]* ["] `[_,A,_] = Node, iolist_to_binary(A)`;
pubidlitsq <- ['] [a-zA-Z0-9()+,./:=?;!*#@$_%\x20\x0d\x0a-]* ['] `[_,A,_] = Node, iolist_to_binary(A)`;

pitarget <- !"xml" name;
namestartchar <- [:A-Z_a-z];
namechar <- [:A-Z_a-z\-.0-9];
name <- namestartchar namechar* `iolist_to_binary(Node)`;
chardata <- [^<&]* `iolist_to_binary(Node)`;
s <- [\x20\x09\x0d\x0A]+ ~;
eq <- s? "=" s? ~;
